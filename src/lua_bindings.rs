/* automatically generated by rust-bindgen 0.72.0 */

pub const __GNUC_VA_LIST: u32 = 1;
pub const WINVER: u32 = 1281;
pub const __MINGW64_VERSION_MAJOR: u32 = 8;
pub const __MINGW64_VERSION_MINOR: u32 = 0;
pub const __MINGW64_VERSION_BUGFIX: u32 = 0;
pub const __MINGW64_VERSION_RC: u32 = 0;
pub const __MINGW64_VERSION_STATE: &[u8; 6] = b"alpha\0";
pub const __MINGW32_MAJOR_VERSION: u32 = 3;
pub const __MINGW32_MINOR_VERSION: u32 = 11;
pub const __: u32 = 1;
pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 0;
pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
pub const __MINGW_GCC_VERSION: u32 = 0;
pub const __MINGW_SEC_WARN_STR : & [u8 ; 92] = b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0" ;
pub const __MINGW_MSVC2005_DEPREC_STR : & [u8 ; 117] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
pub const __MINGW_FORTIFY_LEVEL: u32 = 0;
pub const __MINGW_FORTIFY_VA_ARG: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const USE___UUIDOF: u32 = 1;
pub const __CRT__NO_INLINE: u32 = 1;
pub const __MSVCRT_VERSION__: u32 = 1792;
pub const _WIN32_WINNT: u32 = 1282;
pub const MINGW_HAS_SECURE_API: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const MINGW_HAS_DDK_H: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
pub const _ARGMAX: u32 = 100;
pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
pub const PATH_MAX: u32 = 260;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const _I8_MIN: i32 = -128;
pub const _I8_MAX: u32 = 127;
pub const _UI8_MAX: u32 = 255;
pub const _I16_MIN: i32 = -32768;
pub const _I16_MAX: u32 = 32767;
pub const _UI16_MAX: u32 = 65535;
pub const _I32_MIN: i32 = -2147483648;
pub const _I32_MAX: u32 = 2147483647;
pub const _UI32_MAX: u32 = 4294967295;
pub const _I64_MIN: i64 = -9223372036854775808;
pub const _I64_MAX: u64 = 9223372036854775807;
pub const _UI64_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const LUA_LDIR: &[u8; 7] = b"!\\lua\\\0";
pub const LUA_CDIR: &[u8; 3] = b"!\\\0";
pub const LUA_PATH_DEFAULT: &[u8; 38] = b".\\?.lua;!\\lua\\?.lua;!\\lua\\?\\init.lua;\0";
pub const LUA_CPATH_DEFAULT: &[u8; 30] = b".\\?.dll;!\\?.dll;!\\loadall.dll\0";
pub const LUA_PATH: &[u8; 9] = b"LUA_PATH\0";
pub const LUA_CPATH: &[u8; 10] = b"LUA_CPATH\0";
pub const LUA_INIT: &[u8; 9] = b"LUA_INIT\0";
pub const LUA_DIRSEP: &[u8; 2] = b"\\\0";
pub const LUA_PATHSEP: &[u8; 2] = b";\0";
pub const LUA_PATH_MARK: &[u8; 2] = b"?\0";
pub const LUA_EXECDIR: &[u8; 2] = b"!\0";
pub const LUA_IGMARK: &[u8; 2] = b"-\0";
pub const LUA_PATH_CONFIG: &[u8; 10] = b"\\\n;\n?\n!\n-\0";
pub const LUAI_MAXSTACK: u32 = 65500;
pub const LUAI_MAXCSTACK: u32 = 8000;
pub const LUAI_GCPAUSE: u32 = 200;
pub const LUAI_GCMUL: u32 = 200;
pub const LUA_MAXCAPTURES: u32 = 32;
pub const LUA_IDSIZE: u32 = 60;
pub const LUA_NUMBER_SCAN: &[u8; 4] = b"%lf\0";
pub const LUA_NUMBER_FMT: &[u8; 6] = b"%.14g\0";
pub const LUAI_MAXNUMBER2STR: u32 = 32;
pub const LUA_INTFRMLEN: &[u8; 2] = b"l\0";
pub const LUA_VERSION: &[u8; 8] = b"Lua 5.1\0";
pub const LUA_RELEASE: &[u8; 10] = b"Lua 5.1.4\0";
pub const LUA_VERSION_NUM: u32 = 501;
pub const LUA_COPYRIGHT: &[u8; 41] = b"Copyright (C) 1994-2008 Lua.org, PUC-Rio\0";
pub const LUA_AUTHORS: &[u8; 49] = b"R. Ierusalimschy, L. H. de Figueiredo & W. Celes\0";
pub const LUA_SIGNATURE: &[u8; 5] = b"\x1BLua\0";
pub const LUA_MULTRET: i32 = -1;
pub const LUA_REGISTRYINDEX: i32 = -10000;
pub const LUA_ENVIRONINDEX: i32 = -10001;
pub const LUA_GLOBALSINDEX: i32 = -10002;
pub const LUA_YIELD: u32 = 1;
pub const LUA_ERRRUN: u32 = 2;
pub const LUA_ERRSYNTAX: u32 = 3;
pub const LUA_ERRMEM: u32 = 4;
pub const LUA_ERRERR: u32 = 5;
pub const LUA_TNONE: i32 = -1;
pub const LUA_TNIL: u32 = 0;
pub const LUA_TBOOLEAN: u32 = 1;
pub const LUA_TLIGHTUSERDATA: u32 = 2;
pub const LUA_TNUMBER: u32 = 3;
pub const LUA_TSTRING: u32 = 4;
pub const LUA_TTABLE: u32 = 5;
pub const LUA_TFUNCTION: u32 = 6;
pub const LUA_TUSERDATA: u32 = 7;
pub const LUA_TTHREAD: u32 = 8;
pub const LUA_MINSTACK: u32 = 20;
pub const LUA_GCSTOP: u32 = 0;
pub const LUA_GCRESTART: u32 = 1;
pub const LUA_GCCOLLECT: u32 = 2;
pub const LUA_GCCOUNT: u32 = 3;
pub const LUA_GCCOUNTB: u32 = 4;
pub const LUA_GCSTEP: u32 = 5;
pub const LUA_GCSETPAUSE: u32 = 6;
pub const LUA_GCSETSTEPMUL: u32 = 7;
pub const LUA_HOOKCALL: u32 = 0;
pub const LUA_HOOKRET: u32 = 1;
pub const LUA_HOOKLINE: u32 = 2;
pub const LUA_HOOKCOUNT: u32 = 3;
pub const LUA_HOOKTAILRET: u32 = 4;
pub const LUA_MASKCALL: u32 = 1;
pub const LUA_MASKRET: u32 = 2;
pub const LUA_MASKLINE: u32 = 4;
pub const LUA_MASKCOUNT: u32 = 8;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type rsize_t = usize;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct {
    _unused: [u8; 0],
}
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct localeinfo_struct {
    pub locinfo: pthreadlocinfo,
    pub mbcinfo: pthreadmbcinfo,
}
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLC_ID {
    pub wLanguage: ::std::os::raw::c_ushort,
    pub wCountry: ::std::os::raw::c_ushort,
    pub wCodePage: ::std::os::raw::c_ushort,
}
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct {
    pub refcount: ::std::os::raw::c_int,
    pub lc_codepage: ::std::os::raw::c_uint,
    pub lc_collate_cp: ::std::os::raw::c_uint,
    pub lc_handle: [::std::os::raw::c_ulong; 6usize],
    pub lc_id: [LC_ID; 6usize],
    pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
    pub lc_clike: ::std::os::raw::c_int,
    pub mb_cur_max: ::std::os::raw::c_int,
    pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
    pub lconv_num_refcount: *mut ::std::os::raw::c_int,
    pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
    pub lconv: *mut lconv,
    pub ctype1_refcount: *mut ::std::os::raw::c_int,
    pub ctype1: *mut ::std::os::raw::c_ushort,
    pub pctype: *const ::std::os::raw::c_ushort,
    pub pclmap: *const ::std::os::raw::c_uchar,
    pub pcumap: *const ::std::os::raw::c_uchar,
    pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
    pub locale: *mut ::std::os::raw::c_char,
    pub wlocale: *mut wchar_t,
    pub refcount: *mut ::std::os::raw::c_int,
    pub wrefcount: *mut ::std::os::raw::c_int,
}
pub type threadlocinfo = threadlocaleinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_State {
    _unused: [u8; 0],
}
pub type lua_CFunction =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int>;
pub type lua_Reader = ::std::option::Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        ud: *mut ::std::os::raw::c_void,
        sz: *mut usize,
    ) -> *const ::std::os::raw::c_char,
>;
pub type lua_Writer = ::std::option::Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        p: *const ::std::os::raw::c_void,
        sz: usize,
        ud: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type lua_Alloc = ::std::option::Option<
    unsafe extern "C" fn(
        ud: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        osize: usize,
        nsize: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type lua_Number = f64;
pub type lua_Integer = isize;
pub type lua_Hook =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State, ar: *mut lua_Debug)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_Debug {
    pub event: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub namewhat: *const ::std::os::raw::c_char,
    pub what: *const ::std::os::raw::c_char,
    pub source: *const ::std::os::raw::c_char,
    pub currentline: ::std::os::raw::c_int,
    pub nups: ::std::os::raw::c_int,
    pub linedefined: ::std::os::raw::c_int,
    pub lastlinedefined: ::std::os::raw::c_int,
    pub short_src: [::std::os::raw::c_char; 60usize],
    pub i_ci: ::std::os::raw::c_int,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
pub struct Lua51 {
    __library: ::libloading::Library,
    pub __mingw_get_crt_info:
        Result<unsafe extern "C" fn() -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub lua_newstate: Result<
        unsafe extern "C" fn(f: lua_Alloc, ud: *mut ::std::os::raw::c_void) -> *mut lua_State,
        ::libloading::Error,
    >,
    pub lua_close: Result<unsafe extern "C" fn(L: *mut lua_State), ::libloading::Error>,
    pub lua_newthread:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> *mut lua_State, ::libloading::Error>,
    pub lua_atpanic: Result<
        unsafe extern "C" fn(L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction,
        ::libloading::Error,
    >,
    pub lua_gettop: Result<
        unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_settop: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_pushvalue: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_remove: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_insert: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_replace: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_checkstack: Result<
        unsafe extern "C" fn(L: *mut lua_State, sz: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_xmove: Result<
        unsafe extern "C" fn(from: *mut lua_State, to: *mut lua_State, n: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_isnumber: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_isstring: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_iscfunction: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_isuserdata: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_type: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_typename: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            tp: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_equal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: ::std::os::raw::c_int,
            idx2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_rawequal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: ::std::os::raw::c_int,
            idx2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_lessthan: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: ::std::os::raw::c_int,
            idx2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_tonumber: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int) -> lua_Number,
        ::libloading::Error,
    >,
    pub lua_tointeger: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int) -> lua_Integer,
        ::libloading::Error,
    >,
    pub lua_toboolean: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_tolstring: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
            len: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_objlen: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int) -> usize,
        ::libloading::Error,
    >,
    pub lua_tocfunction: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int) -> lua_CFunction,
        ::libloading::Error,
    >,
    pub lua_touserdata: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub lua_tothread: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int) -> *mut lua_State,
        ::libloading::Error,
    >,
    pub lua_topointer: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub lua_pushnil: Result<unsafe extern "C" fn(L: *mut lua_State), ::libloading::Error>,
    pub lua_pushnumber:
        Result<unsafe extern "C" fn(L: *mut lua_State, n: lua_Number), ::libloading::Error>,
    pub lua_pushinteger:
        Result<unsafe extern "C" fn(L: *mut lua_State, n: lua_Integer), ::libloading::Error>,
    pub lua_pushlstring: Result<
        unsafe extern "C" fn(L: *mut lua_State, s: *const ::std::os::raw::c_char, l: usize),
        ::libloading::Error,
    >,
    pub lua_pushstring: Result<
        unsafe extern "C" fn(L: *mut lua_State, s: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub lua_pushvfstring: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            fmt: *const ::std::os::raw::c_char,
            argp: va_list,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_pushfstring: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_pushcclosure: Result<
        unsafe extern "C" fn(L: *mut lua_State, fn_: lua_CFunction, n: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_pushboolean: Result<
        unsafe extern "C" fn(L: *mut lua_State, b: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_pushlightuserdata: Result<
        unsafe extern "C" fn(L: *mut lua_State, p: *mut ::std::os::raw::c_void),
        ::libloading::Error,
    >,
    pub lua_pushthread: Result<
        unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_gettable: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_getfield: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
            k: *const ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub lua_rawget: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_rawgeti: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub lua_createtable: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            narr: ::std::os::raw::c_int,
            nrec: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub lua_newuserdata: Result<
        unsafe extern "C" fn(L: *mut lua_State, sz: usize) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub lua_getmetatable: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            objindex: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_getfenv: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_settable: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_setfield: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
            k: *const ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub lua_rawset: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_rawseti: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub lua_setmetatable: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            objindex: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_setfenv: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_call: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            nargs: ::std::os::raw::c_int,
            nresults: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub lua_pcall: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            nargs: ::std::os::raw::c_int,
            nresults: ::std::os::raw::c_int,
            errfunc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_cpcall: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            func: lua_CFunction,
            ud: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_load: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            reader: lua_Reader,
            dt: *mut ::std::os::raw::c_void,
            chunkname: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_dump: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            writer: lua_Writer,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_yield: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            nresults: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_resume: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            narg: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_status: Result<
        unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_gc: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            what: ::std::os::raw::c_int,
            data: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_error: Result<
        unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_next: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_concat: Result<
        unsafe extern "C" fn(L: *mut lua_State, n: ::std::os::raw::c_int),
        ::libloading::Error,
    >,
    pub lua_getallocf: Result<
        unsafe extern "C" fn(L: *mut lua_State, ud: *mut *mut ::std::os::raw::c_void) -> lua_Alloc,
        ::libloading::Error,
    >,
    pub lua_setallocf: Result<
        unsafe extern "C" fn(L: *mut lua_State, f: lua_Alloc, ud: *mut ::std::os::raw::c_void),
        ::libloading::Error,
    >,
    pub lua_setlevel:
        Result<unsafe extern "C" fn(from: *mut lua_State, to: *mut lua_State), ::libloading::Error>,
    pub lua_getstack: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            level: ::std::os::raw::c_int,
            ar: *mut lua_Debug,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_getinfo: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            what: *const ::std::os::raw::c_char,
            ar: *mut lua_Debug,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_getlocal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            ar: *const lua_Debug,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_setlocal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            ar: *const lua_Debug,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_getupvalue: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            funcindex: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_setupvalue: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            funcindex: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub lua_sethook: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            func: lua_Hook,
            mask: ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_gethook:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> lua_Hook, ::libloading::Error>,
    pub lua_gethookmask: Result<
        unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_gethookcount: Result<
        unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lua_upvalueid: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub lua_upvaluejoin: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: ::std::os::raw::c_int,
            n1: ::std::os::raw::c_int,
            idx2: ::std::os::raw::c_int,
            n2: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub lua_loadx: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            reader: lua_Reader,
            dt: *mut ::std::os::raw::c_void,
            chunkname: *const ::std::os::raw::c_char,
            mode: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
}
impl Lua51 {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let __mingw_get_crt_info = __library.get(b"__mingw_get_crt_info\0").map(|sym| *sym);
        let lua_newstate = __library.get(b"lua_newstate\0").map(|sym| *sym);
        let lua_close = __library.get(b"lua_close\0").map(|sym| *sym);
        let lua_newthread = __library.get(b"lua_newthread\0").map(|sym| *sym);
        let lua_atpanic = __library.get(b"lua_atpanic\0").map(|sym| *sym);
        let lua_gettop = __library.get(b"lua_gettop\0").map(|sym| *sym);
        let lua_settop = __library.get(b"lua_settop\0").map(|sym| *sym);
        let lua_pushvalue = __library.get(b"lua_pushvalue\0").map(|sym| *sym);
        let lua_remove = __library.get(b"lua_remove\0").map(|sym| *sym);
        let lua_insert = __library.get(b"lua_insert\0").map(|sym| *sym);
        let lua_replace = __library.get(b"lua_replace\0").map(|sym| *sym);
        let lua_checkstack = __library.get(b"lua_checkstack\0").map(|sym| *sym);
        let lua_xmove = __library.get(b"lua_xmove\0").map(|sym| *sym);
        let lua_isnumber = __library.get(b"lua_isnumber\0").map(|sym| *sym);
        let lua_isstring = __library.get(b"lua_isstring\0").map(|sym| *sym);
        let lua_iscfunction = __library.get(b"lua_iscfunction\0").map(|sym| *sym);
        let lua_isuserdata = __library.get(b"lua_isuserdata\0").map(|sym| *sym);
        let lua_type = __library.get(b"lua_type\0").map(|sym| *sym);
        let lua_typename = __library.get(b"lua_typename\0").map(|sym| *sym);
        let lua_equal = __library.get(b"lua_equal\0").map(|sym| *sym);
        let lua_rawequal = __library.get(b"lua_rawequal\0").map(|sym| *sym);
        let lua_lessthan = __library.get(b"lua_lessthan\0").map(|sym| *sym);
        let lua_tonumber = __library.get(b"lua_tonumber\0").map(|sym| *sym);
        let lua_tointeger = __library.get(b"lua_tointeger\0").map(|sym| *sym);
        let lua_toboolean = __library.get(b"lua_toboolean\0").map(|sym| *sym);
        let lua_tolstring = __library.get(b"lua_tolstring\0").map(|sym| *sym);
        let lua_objlen = __library.get(b"lua_objlen\0").map(|sym| *sym);
        let lua_tocfunction = __library.get(b"lua_tocfunction\0").map(|sym| *sym);
        let lua_touserdata = __library.get(b"lua_touserdata\0").map(|sym| *sym);
        let lua_tothread = __library.get(b"lua_tothread\0").map(|sym| *sym);
        let lua_topointer = __library.get(b"lua_topointer\0").map(|sym| *sym);
        let lua_pushnil = __library.get(b"lua_pushnil\0").map(|sym| *sym);
        let lua_pushnumber = __library.get(b"lua_pushnumber\0").map(|sym| *sym);
        let lua_pushinteger = __library.get(b"lua_pushinteger\0").map(|sym| *sym);
        let lua_pushlstring = __library.get(b"lua_pushlstring\0").map(|sym| *sym);
        let lua_pushstring = __library.get(b"lua_pushstring\0").map(|sym| *sym);
        let lua_pushvfstring = __library.get(b"lua_pushvfstring\0").map(|sym| *sym);
        let lua_pushfstring = __library.get(b"lua_pushfstring\0").map(|sym| *sym);
        let lua_pushcclosure = __library.get(b"lua_pushcclosure\0").map(|sym| *sym);
        let lua_pushboolean = __library.get(b"lua_pushboolean\0").map(|sym| *sym);
        let lua_pushlightuserdata = __library.get(b"lua_pushlightuserdata\0").map(|sym| *sym);
        let lua_pushthread = __library.get(b"lua_pushthread\0").map(|sym| *sym);
        let lua_gettable = __library.get(b"lua_gettable\0").map(|sym| *sym);
        let lua_getfield = __library.get(b"lua_getfield\0").map(|sym| *sym);
        let lua_rawget = __library.get(b"lua_rawget\0").map(|sym| *sym);
        let lua_rawgeti = __library.get(b"lua_rawgeti\0").map(|sym| *sym);
        let lua_createtable = __library.get(b"lua_createtable\0").map(|sym| *sym);
        let lua_newuserdata = __library.get(b"lua_newuserdata\0").map(|sym| *sym);
        let lua_getmetatable = __library.get(b"lua_getmetatable\0").map(|sym| *sym);
        let lua_getfenv = __library.get(b"lua_getfenv\0").map(|sym| *sym);
        let lua_settable = __library.get(b"lua_settable\0").map(|sym| *sym);
        let lua_setfield = __library.get(b"lua_setfield\0").map(|sym| *sym);
        let lua_rawset = __library.get(b"lua_rawset\0").map(|sym| *sym);
        let lua_rawseti = __library.get(b"lua_rawseti\0").map(|sym| *sym);
        let lua_setmetatable = __library.get(b"lua_setmetatable\0").map(|sym| *sym);
        let lua_setfenv = __library.get(b"lua_setfenv\0").map(|sym| *sym);
        let lua_call = __library.get(b"lua_call\0").map(|sym| *sym);
        let lua_pcall = __library.get(b"lua_pcall\0").map(|sym| *sym);
        let lua_cpcall = __library.get(b"lua_cpcall\0").map(|sym| *sym);
        let lua_load = __library.get(b"lua_load\0").map(|sym| *sym);
        let lua_dump = __library.get(b"lua_dump\0").map(|sym| *sym);
        let lua_yield = __library.get(b"lua_yield\0").map(|sym| *sym);
        let lua_resume = __library.get(b"lua_resume\0").map(|sym| *sym);
        let lua_status = __library.get(b"lua_status\0").map(|sym| *sym);
        let lua_gc = __library.get(b"lua_gc\0").map(|sym| *sym);
        let lua_error = __library.get(b"lua_error\0").map(|sym| *sym);
        let lua_next = __library.get(b"lua_next\0").map(|sym| *sym);
        let lua_concat = __library.get(b"lua_concat\0").map(|sym| *sym);
        let lua_getallocf = __library.get(b"lua_getallocf\0").map(|sym| *sym);
        let lua_setallocf = __library.get(b"lua_setallocf\0").map(|sym| *sym);
        let lua_setlevel = __library.get(b"lua_setlevel\0").map(|sym| *sym);
        let lua_getstack = __library.get(b"lua_getstack\0").map(|sym| *sym);
        let lua_getinfo = __library.get(b"lua_getinfo\0").map(|sym| *sym);
        let lua_getlocal = __library.get(b"lua_getlocal\0").map(|sym| *sym);
        let lua_setlocal = __library.get(b"lua_setlocal\0").map(|sym| *sym);
        let lua_getupvalue = __library.get(b"lua_getupvalue\0").map(|sym| *sym);
        let lua_setupvalue = __library.get(b"lua_setupvalue\0").map(|sym| *sym);
        let lua_sethook = __library.get(b"lua_sethook\0").map(|sym| *sym);
        let lua_gethook = __library.get(b"lua_gethook\0").map(|sym| *sym);
        let lua_gethookmask = __library.get(b"lua_gethookmask\0").map(|sym| *sym);
        let lua_gethookcount = __library.get(b"lua_gethookcount\0").map(|sym| *sym);
        let lua_upvalueid = __library.get(b"lua_upvalueid\0").map(|sym| *sym);
        let lua_upvaluejoin = __library.get(b"lua_upvaluejoin\0").map(|sym| *sym);
        let lua_loadx = __library.get(b"lua_loadx\0").map(|sym| *sym);
        Ok(Lua51 {
            __library,
            __mingw_get_crt_info,
            lua_newstate,
            lua_close,
            lua_newthread,
            lua_atpanic,
            lua_gettop,
            lua_settop,
            lua_pushvalue,
            lua_remove,
            lua_insert,
            lua_replace,
            lua_checkstack,
            lua_xmove,
            lua_isnumber,
            lua_isstring,
            lua_iscfunction,
            lua_isuserdata,
            lua_type,
            lua_typename,
            lua_equal,
            lua_rawequal,
            lua_lessthan,
            lua_tonumber,
            lua_tointeger,
            lua_toboolean,
            lua_tolstring,
            lua_objlen,
            lua_tocfunction,
            lua_touserdata,
            lua_tothread,
            lua_topointer,
            lua_pushnil,
            lua_pushnumber,
            lua_pushinteger,
            lua_pushlstring,
            lua_pushstring,
            lua_pushvfstring,
            lua_pushfstring,
            lua_pushcclosure,
            lua_pushboolean,
            lua_pushlightuserdata,
            lua_pushthread,
            lua_gettable,
            lua_getfield,
            lua_rawget,
            lua_rawgeti,
            lua_createtable,
            lua_newuserdata,
            lua_getmetatable,
            lua_getfenv,
            lua_settable,
            lua_setfield,
            lua_rawset,
            lua_rawseti,
            lua_setmetatable,
            lua_setfenv,
            lua_call,
            lua_pcall,
            lua_cpcall,
            lua_load,
            lua_dump,
            lua_yield,
            lua_resume,
            lua_status,
            lua_gc,
            lua_error,
            lua_next,
            lua_concat,
            lua_getallocf,
            lua_setallocf,
            lua_setlevel,
            lua_getstack,
            lua_getinfo,
            lua_getlocal,
            lua_setlocal,
            lua_getupvalue,
            lua_setupvalue,
            lua_sethook,
            lua_gethook,
            lua_gethookmask,
            lua_gethookcount,
            lua_upvalueid,
            lua_upvaluejoin,
            lua_loadx,
        })
    }
    pub unsafe fn __mingw_get_crt_info(&self) -> *const ::std::os::raw::c_char {
        (self
            .__mingw_get_crt_info
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn lua_newstate(
        &self,
        f: lua_Alloc,
        ud: *mut ::std::os::raw::c_void,
    ) -> *mut lua_State {
        (self
            .lua_newstate
            .as_ref()
            .expect("Expected function, got error."))(f, ud)
    }
    pub unsafe fn lua_close(&self, L: *mut lua_State) {
        (self
            .lua_close
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_newthread(&self, L: *mut lua_State) -> *mut lua_State {
        (self
            .lua_newthread
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_atpanic(&self, L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction {
        (self
            .lua_atpanic
            .as_ref()
            .expect("Expected function, got error."))(L, panicf)
    }
    pub unsafe fn lua_gettop(&self, L: *mut lua_State) -> ::std::os::raw::c_int {
        (self
            .lua_gettop
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_settop(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_settop
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_pushvalue(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_pushvalue
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_remove(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_remove
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_insert(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_insert
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_replace(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_replace
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_checkstack(
        &self,
        L: *mut lua_State,
        sz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_checkstack
            .as_ref()
            .expect("Expected function, got error."))(L, sz)
    }
    pub unsafe fn lua_xmove(
        &self,
        from: *mut lua_State,
        to: *mut lua_State,
        n: ::std::os::raw::c_int,
    ) {
        (self
            .lua_xmove
            .as_ref()
            .expect("Expected function, got error."))(from, to, n)
    }
    pub unsafe fn lua_isnumber(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_isnumber
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_isstring(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_isstring
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_iscfunction(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_iscfunction
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_isuserdata(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_isuserdata
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_type(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_type
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_typename(
        &self,
        L: *mut lua_State,
        tp: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .lua_typename
            .as_ref()
            .expect("Expected function, got error."))(L, tp)
    }
    pub unsafe fn lua_equal(
        &self,
        L: *mut lua_State,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_equal
            .as_ref()
            .expect("Expected function, got error."))(L, idx1, idx2)
    }
    pub unsafe fn lua_rawequal(
        &self,
        L: *mut lua_State,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_rawequal
            .as_ref()
            .expect("Expected function, got error."))(L, idx1, idx2)
    }
    pub unsafe fn lua_lessthan(
        &self,
        L: *mut lua_State,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_lessthan
            .as_ref()
            .expect("Expected function, got error."))(L, idx1, idx2)
    }
    pub unsafe fn lua_tonumber(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) -> lua_Number {
        (self
            .lua_tonumber
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_tointeger(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> lua_Integer {
        (self
            .lua_tointeger
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_toboolean(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_toboolean
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_tolstring(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        len: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .lua_tolstring
            .as_ref()
            .expect("Expected function, got error."))(L, idx, len)
    }
    pub unsafe fn lua_objlen(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) -> usize {
        (self
            .lua_objlen
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_tocfunction(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> lua_CFunction {
        (self
            .lua_tocfunction
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_touserdata(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .lua_touserdata
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_tothread(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> *mut lua_State {
        (self
            .lua_tothread
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_topointer(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void {
        (self
            .lua_topointer
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_pushnil(&self, L: *mut lua_State) {
        (self
            .lua_pushnil
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_pushnumber(&self, L: *mut lua_State, n: lua_Number) {
        (self
            .lua_pushnumber
            .as_ref()
            .expect("Expected function, got error."))(L, n)
    }
    pub unsafe fn lua_pushinteger(&self, L: *mut lua_State, n: lua_Integer) {
        (self
            .lua_pushinteger
            .as_ref()
            .expect("Expected function, got error."))(L, n)
    }
    pub unsafe fn lua_pushlstring(
        &self,
        L: *mut lua_State,
        s: *const ::std::os::raw::c_char,
        l: usize,
    ) {
        (self
            .lua_pushlstring
            .as_ref()
            .expect("Expected function, got error."))(L, s, l)
    }
    pub unsafe fn lua_pushstring(&self, L: *mut lua_State, s: *const ::std::os::raw::c_char) {
        (self
            .lua_pushstring
            .as_ref()
            .expect("Expected function, got error."))(L, s)
    }
    pub unsafe fn lua_pushvfstring(
        &self,
        L: *mut lua_State,
        fmt: *const ::std::os::raw::c_char,
        argp: va_list,
    ) -> *const ::std::os::raw::c_char {
        (self
            .lua_pushvfstring
            .as_ref()
            .expect("Expected function, got error."))(L, fmt, argp)
    }
    pub unsafe fn lua_pushcclosure(
        &self,
        L: *mut lua_State,
        fn_: lua_CFunction,
        n: ::std::os::raw::c_int,
    ) {
        (self
            .lua_pushcclosure
            .as_ref()
            .expect("Expected function, got error."))(L, fn_, n)
    }
    pub unsafe fn lua_pushboolean(&self, L: *mut lua_State, b: ::std::os::raw::c_int) {
        (self
            .lua_pushboolean
            .as_ref()
            .expect("Expected function, got error."))(L, b)
    }
    pub unsafe fn lua_pushlightuserdata(&self, L: *mut lua_State, p: *mut ::std::os::raw::c_void) {
        (self
            .lua_pushlightuserdata
            .as_ref()
            .expect("Expected function, got error."))(L, p)
    }
    pub unsafe fn lua_pushthread(&self, L: *mut lua_State) -> ::std::os::raw::c_int {
        (self
            .lua_pushthread
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_gettable(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_gettable
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_getfield(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_char,
    ) {
        (self
            .lua_getfield
            .as_ref()
            .expect("Expected function, got error."))(L, idx, k)
    }
    pub unsafe fn lua_rawget(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_rawget
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_rawgeti(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) {
        (self
            .lua_rawgeti
            .as_ref()
            .expect("Expected function, got error."))(L, idx, n)
    }
    pub unsafe fn lua_createtable(
        &self,
        L: *mut lua_State,
        narr: ::std::os::raw::c_int,
        nrec: ::std::os::raw::c_int,
    ) {
        (self
            .lua_createtable
            .as_ref()
            .expect("Expected function, got error."))(L, narr, nrec)
    }
    pub unsafe fn lua_newuserdata(
        &self,
        L: *mut lua_State,
        sz: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .lua_newuserdata
            .as_ref()
            .expect("Expected function, got error."))(L, sz)
    }
    pub unsafe fn lua_getmetatable(
        &self,
        L: *mut lua_State,
        objindex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_getmetatable
            .as_ref()
            .expect("Expected function, got error."))(L, objindex)
    }
    pub unsafe fn lua_getfenv(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_getfenv
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_settable(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_settable
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_setfield(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_char,
    ) {
        (self
            .lua_setfield
            .as_ref()
            .expect("Expected function, got error."))(L, idx, k)
    }
    pub unsafe fn lua_rawset(&self, L: *mut lua_State, idx: ::std::os::raw::c_int) {
        (self
            .lua_rawset
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_rawseti(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) {
        (self
            .lua_rawseti
            .as_ref()
            .expect("Expected function, got error."))(L, idx, n)
    }
    pub unsafe fn lua_setmetatable(
        &self,
        L: *mut lua_State,
        objindex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_setmetatable
            .as_ref()
            .expect("Expected function, got error."))(L, objindex)
    }
    pub unsafe fn lua_setfenv(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_setfenv
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_call(
        &self,
        L: *mut lua_State,
        nargs: ::std::os::raw::c_int,
        nresults: ::std::os::raw::c_int,
    ) {
        (self
            .lua_call
            .as_ref()
            .expect("Expected function, got error."))(L, nargs, nresults)
    }
    pub unsafe fn lua_pcall(
        &self,
        L: *mut lua_State,
        nargs: ::std::os::raw::c_int,
        nresults: ::std::os::raw::c_int,
        errfunc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_pcall
            .as_ref()
            .expect("Expected function, got error."))(L, nargs, nresults, errfunc)
    }
    pub unsafe fn lua_cpcall(
        &self,
        L: *mut lua_State,
        func: lua_CFunction,
        ud: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_cpcall
            .as_ref()
            .expect("Expected function, got error."))(L, func, ud)
    }
    pub unsafe fn lua_load(
        &self,
        L: *mut lua_State,
        reader: lua_Reader,
        dt: *mut ::std::os::raw::c_void,
        chunkname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_load
            .as_ref()
            .expect("Expected function, got error."))(L, reader, dt, chunkname)
    }
    pub unsafe fn lua_dump(
        &self,
        L: *mut lua_State,
        writer: lua_Writer,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_dump
            .as_ref()
            .expect("Expected function, got error."))(L, writer, data)
    }
    pub unsafe fn lua_yield(
        &self,
        L: *mut lua_State,
        nresults: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_yield
            .as_ref()
            .expect("Expected function, got error."))(L, nresults)
    }
    pub unsafe fn lua_resume(
        &self,
        L: *mut lua_State,
        narg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_resume
            .as_ref()
            .expect("Expected function, got error."))(L, narg)
    }
    pub unsafe fn lua_status(&self, L: *mut lua_State) -> ::std::os::raw::c_int {
        (self
            .lua_status
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_gc(
        &self,
        L: *mut lua_State,
        what: ::std::os::raw::c_int,
        data: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.lua_gc.as_ref().expect("Expected function, got error."))(L, what, data)
    }
    pub unsafe fn lua_error(&self, L: *mut lua_State) -> ::std::os::raw::c_int {
        (self
            .lua_error
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_next(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_next
            .as_ref()
            .expect("Expected function, got error."))(L, idx)
    }
    pub unsafe fn lua_concat(&self, L: *mut lua_State, n: ::std::os::raw::c_int) {
        (self
            .lua_concat
            .as_ref()
            .expect("Expected function, got error."))(L, n)
    }
    pub unsafe fn lua_getallocf(
        &self,
        L: *mut lua_State,
        ud: *mut *mut ::std::os::raw::c_void,
    ) -> lua_Alloc {
        (self
            .lua_getallocf
            .as_ref()
            .expect("Expected function, got error."))(L, ud)
    }
    pub unsafe fn lua_setallocf(
        &self,
        L: *mut lua_State,
        f: lua_Alloc,
        ud: *mut ::std::os::raw::c_void,
    ) {
        (self
            .lua_setallocf
            .as_ref()
            .expect("Expected function, got error."))(L, f, ud)
    }
    pub unsafe fn lua_setlevel(&self, from: *mut lua_State, to: *mut lua_State) {
        (self
            .lua_setlevel
            .as_ref()
            .expect("Expected function, got error."))(from, to)
    }
    pub unsafe fn lua_getstack(
        &self,
        L: *mut lua_State,
        level: ::std::os::raw::c_int,
        ar: *mut lua_Debug,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_getstack
            .as_ref()
            .expect("Expected function, got error."))(L, level, ar)
    }
    pub unsafe fn lua_getinfo(
        &self,
        L: *mut lua_State,
        what: *const ::std::os::raw::c_char,
        ar: *mut lua_Debug,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_getinfo
            .as_ref()
            .expect("Expected function, got error."))(L, what, ar)
    }
    pub unsafe fn lua_getlocal(
        &self,
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .lua_getlocal
            .as_ref()
            .expect("Expected function, got error."))(L, ar, n)
    }
    pub unsafe fn lua_setlocal(
        &self,
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .lua_setlocal
            .as_ref()
            .expect("Expected function, got error."))(L, ar, n)
    }
    pub unsafe fn lua_getupvalue(
        &self,
        L: *mut lua_State,
        funcindex: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .lua_getupvalue
            .as_ref()
            .expect("Expected function, got error."))(L, funcindex, n)
    }
    pub unsafe fn lua_setupvalue(
        &self,
        L: *mut lua_State,
        funcindex: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .lua_setupvalue
            .as_ref()
            .expect("Expected function, got error."))(L, funcindex, n)
    }
    pub unsafe fn lua_sethook(
        &self,
        L: *mut lua_State,
        func: lua_Hook,
        mask: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_sethook
            .as_ref()
            .expect("Expected function, got error."))(L, func, mask, count)
    }
    pub unsafe fn lua_gethook(&self, L: *mut lua_State) -> lua_Hook {
        (self
            .lua_gethook
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_gethookmask(&self, L: *mut lua_State) -> ::std::os::raw::c_int {
        (self
            .lua_gethookmask
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_gethookcount(&self, L: *mut lua_State) -> ::std::os::raw::c_int {
        (self
            .lua_gethookcount
            .as_ref()
            .expect("Expected function, got error."))(L)
    }
    pub unsafe fn lua_upvalueid(
        &self,
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .lua_upvalueid
            .as_ref()
            .expect("Expected function, got error."))(L, idx, n)
    }
    pub unsafe fn lua_upvaluejoin(
        &self,
        L: *mut lua_State,
        idx1: ::std::os::raw::c_int,
        n1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        n2: ::std::os::raw::c_int,
    ) {
        (self
            .lua_upvaluejoin
            .as_ref()
            .expect("Expected function, got error."))(L, idx1, n1, idx2, n2)
    }
    pub unsafe fn lua_loadx(
        &self,
        L: *mut lua_State,
        reader: lua_Reader,
        dt: *mut ::std::os::raw::c_void,
        chunkname: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .lua_loadx
            .as_ref()
            .expect("Expected function, got error."))(L, reader, dt, chunkname, mode)
    }
}
