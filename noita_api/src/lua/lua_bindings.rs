/* automatically generated by rust-bindgen 0.70.0 */

#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub const WINVER: u32 = 1281;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const LUA_MULTILIB: &[u8; 4] = b"lib\0";
pub const LUA_LMULTILIB: &[u8; 4] = b"lib\0";
pub const LUA_LROOT: &[u8; 11] = b"/usr/local\0";
pub const LUA_LUADIR: &[u8; 10] = b"/lua/5.1/\0";
pub const LUA_LJDIR: &[u8; 15] = b"/luajit-2.0.4/\0";
pub const LUA_JROOT: &[u8; 11] = b"/usr/local\0";
pub const LUA_JPATH: &[u8; 37] = b";/usr/local/share/luajit-2.0.4/?.lua\0";
pub const LUA_LLDIR: &[u8; 26] = b"/usr/local/share/lua/5.1/\0";
pub const LUA_LCDIR: &[u8; 24] = b"/usr/local/lib/lua/5.1/\0";
pub const LUA_LLPATH: &[u8; 68] =
    b";/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua\0";
pub const LUA_LCPATH1: &[u8; 29] = b";/usr/local/lib/lua/5.1/?.so\0";
pub const LUA_LCPATH2: &[u8; 35] = b";/usr/local/lib/lua/5.1/loadall.so\0";
pub const LUA_PATH: &[u8; 9] = b"LUA_PATH\0";
pub const LUA_CPATH: &[u8; 10] = b"LUA_CPATH\0";
pub const LUA_INIT: &[u8; 9] = b"LUA_INIT\0";
pub const LUA_DIRSEP: &[u8; 2] = b"/\0";
pub const LUA_PATHSEP: &[u8; 2] = b";\0";
pub const LUA_PATH_MARK: &[u8; 2] = b"?\0";
pub const LUA_EXECDIR: &[u8; 2] = b"!\0";
pub const LUA_IGMARK: &[u8; 2] = b"-\0";
pub const LUA_PATH_CONFIG: &[u8; 10] = b"/\n;\n?\n!\n-\0";
pub const LUAI_MAXSTACK: u32 = 65500;
pub const LUAI_MAXCSTACK: u32 = 8000;
pub const LUAI_GCPAUSE: u32 = 200;
pub const LUAI_GCMUL: u32 = 200;
pub const LUA_MAXCAPTURES: u32 = 32;
pub const LUA_IDSIZE: u32 = 60;
pub const LUA_NUMBER_SCAN: &[u8; 4] = b"%lf\0";
pub const LUA_NUMBER_FMT: &[u8; 6] = b"%.14g\0";
pub const LUAI_MAXNUMBER2STR: u32 = 32;
pub const LUA_INTFRMLEN: &[u8; 2] = b"l\0";
pub const LUA_VERSION: &[u8; 8] = b"Lua 5.1\0";
pub const LUA_RELEASE: &[u8; 10] = b"Lua 5.1.4\0";
pub const LUA_VERSION_NUM: u32 = 501;
pub const LUA_COPYRIGHT: &[u8; 41] = b"Copyright (C) 1994-2008 Lua.org, PUC-Rio\0";
pub const LUA_AUTHORS: &[u8; 49] = b"R. Ierusalimschy, L. H. de Figueiredo & W. Celes\0";
pub const LUA_SIGNATURE: &[u8; 5] = b"\x1BLua\0";
pub const LUA_MULTRET: i32 = -1;
pub const LUA_REGISTRYINDEX: i32 = -10000;
pub const LUA_ENVIRONINDEX: i32 = -10001;
pub const LUA_GLOBALSINDEX: i32 = -10002;
pub const LUA_YIELD: u32 = 1;
pub const LUA_ERRRUN: u32 = 2;
pub const LUA_ERRSYNTAX: u32 = 3;
pub const LUA_ERRMEM: u32 = 4;
pub const LUA_ERRERR: u32 = 5;
pub const LUA_TNONE: i32 = -1;
pub const LUA_TNIL: u32 = 0;
pub const LUA_TBOOLEAN: u32 = 1;
pub const LUA_TLIGHTUSERDATA: u32 = 2;
pub const LUA_TNUMBER: u32 = 3;
pub const LUA_TSTRING: u32 = 4;
pub const LUA_TTABLE: u32 = 5;
pub const LUA_TFUNCTION: u32 = 6;
pub const LUA_TUSERDATA: u32 = 7;
pub const LUA_TTHREAD: u32 = 8;
pub const LUA_MINSTACK: u32 = 20;
pub const LUA_GCSTOP: u32 = 0;
pub const LUA_GCRESTART: u32 = 1;
pub const LUA_GCCOLLECT: u32 = 2;
pub const LUA_GCCOUNT: u32 = 3;
pub const LUA_GCCOUNTB: u32 = 4;
pub const LUA_GCSTEP: u32 = 5;
pub const LUA_GCSETPAUSE: u32 = 6;
pub const LUA_GCSETSTEPMUL: u32 = 7;
pub const LUA_HOOKCALL: u32 = 0;
pub const LUA_HOOKRET: u32 = 1;
pub const LUA_HOOKLINE: u32 = 2;
pub const LUA_HOOKCOUNT: u32 = 3;
pub const LUA_HOOKTAILRET: u32 = 4;
pub const LUA_MASKCALL: u32 = 1;
pub const LUA_MASKRET: u32 = 2;
pub const LUA_MASKLINE: u32 = 4;
pub const LUA_MASKCOUNT: u32 = 8;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_State {
    _unused: [u8; 0],
}
pub type lua_CFunction = Option<unsafe extern "C" fn(L: *mut lua_State) -> std::os::raw::c_int>;
pub type lua_Reader = Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        ud: *mut std::os::raw::c_void,
        sz: *mut usize,
    ) -> *const std::os::raw::c_char,
>;
pub type lua_Writer = Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        p: *const std::os::raw::c_void,
        sz: usize,
        ud: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int,
>;
pub type lua_Alloc = Option<
    unsafe extern "C" fn(
        ud: *mut std::os::raw::c_void,
        ptr: *mut std::os::raw::c_void,
        osize: usize,
        nsize: usize,
    ) -> *mut std::os::raw::c_void,
>;
pub type lua_Number = f64;
pub type lua_Integer = isize;
pub type lua_Hook = Option<unsafe extern "C" fn(L: *mut lua_State, ar: *mut lua_Debug)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_Debug {
    pub event: std::os::raw::c_int,
    pub name: *const std::os::raw::c_char,
    pub namewhat: *const std::os::raw::c_char,
    pub what: *const std::os::raw::c_char,
    pub source: *const std::os::raw::c_char,
    pub currentline: std::os::raw::c_int,
    pub nups: std::os::raw::c_int,
    pub linedefined: std::os::raw::c_int,
    pub lastlinedefined: std::os::raw::c_int,
    pub short_src: [std::os::raw::c_char; 60usize],
    pub i_ci: std::os::raw::c_int,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: std::os::raw::c_uint,
    pub fp_offset: std::os::raw::c_uint,
    pub overflow_arg_area: *mut std::os::raw::c_void,
    pub reg_save_area: *mut std::os::raw::c_void,
}
pub struct Lua51 {
    __library: libloading::Library,
    pub lua_newstate: Result<
        unsafe extern "C" fn(f: lua_Alloc, ud: *mut std::os::raw::c_void) -> *mut lua_State,
        libloading::Error,
    >,
    pub lua_close: Result<unsafe extern "C" fn(L: *mut lua_State), libloading::Error>,
    pub lua_newthread:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> *mut lua_State, libloading::Error>,
    pub lua_atpanic: Result<
        unsafe extern "C" fn(L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction,
        libloading::Error,
    >,
    pub lua_gettop:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> std::os::raw::c_int, libloading::Error>,
    pub lua_settop: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_pushvalue: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_remove: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_insert: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_replace: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_checkstack: Result<
        unsafe extern "C" fn(L: *mut lua_State, sz: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_xmove: Result<
        unsafe extern "C" fn(from: *mut lua_State, to: *mut lua_State, n: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_isnumber: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_isstring: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_iscfunction: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_isuserdata: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_type: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_typename: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            tp: std::os::raw::c_int,
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_equal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: std::os::raw::c_int,
            idx2: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_rawequal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: std::os::raw::c_int,
            idx2: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_lessthan: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: std::os::raw::c_int,
            idx2: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_tonumber: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> lua_Number,
        libloading::Error,
    >,
    pub lua_tointeger: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> lua_Integer,
        libloading::Error,
    >,
    pub lua_toboolean: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_tolstring: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: std::os::raw::c_int,
            len: *mut usize,
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_objlen: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> usize,
        libloading::Error,
    >,
    pub lua_tocfunction: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> lua_CFunction,
        libloading::Error,
    >,
    pub lua_touserdata: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: std::os::raw::c_int,
        ) -> *mut std::os::raw::c_void,
        libloading::Error,
    >,
    pub lua_tothread: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> *mut lua_State,
        libloading::Error,
    >,
    pub lua_topointer: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: std::os::raw::c_int,
        ) -> *const std::os::raw::c_void,
        libloading::Error,
    >,
    pub lua_pushnil: Result<unsafe extern "C" fn(L: *mut lua_State), libloading::Error>,
    pub lua_pushnumber:
        Result<unsafe extern "C" fn(L: *mut lua_State, n: lua_Number), libloading::Error>,
    pub lua_pushinteger:
        Result<unsafe extern "C" fn(L: *mut lua_State, n: lua_Integer), libloading::Error>,
    pub lua_pushlstring: Result<
        unsafe extern "C" fn(L: *mut lua_State, s: *const std::os::raw::c_char, l: usize),
        libloading::Error,
    >,
    pub lua_pushstring: Result<
        unsafe extern "C" fn(L: *mut lua_State, s: *const std::os::raw::c_char),
        libloading::Error,
    >,
    pub lua_pushvfstring: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            fmt: *const std::os::raw::c_char,
            argp: *mut __va_list_tag,
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_pushfstring: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            fmt: *const std::os::raw::c_char,
            ...
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_pushcclosure: Result<
        unsafe extern "C" fn(L: *mut lua_State, fn_: lua_CFunction, n: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_pushboolean:
        Result<unsafe extern "C" fn(L: *mut lua_State, b: std::os::raw::c_int), libloading::Error>,
    pub lua_pushlightuserdata: Result<
        unsafe extern "C" fn(L: *mut lua_State, p: *mut std::os::raw::c_void),
        libloading::Error,
    >,
    pub lua_pushthread:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> std::os::raw::c_int, libloading::Error>,
    pub lua_gettable: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_getfield: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: std::os::raw::c_int,
            k: *const std::os::raw::c_char,
        ),
        libloading::Error,
    >,
    pub lua_rawget: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_rawgeti: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int, n: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_createtable: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            narr: std::os::raw::c_int,
            nrec: std::os::raw::c_int,
        ),
        libloading::Error,
    >,
    pub lua_newuserdata: Result<
        unsafe extern "C" fn(L: *mut lua_State, sz: usize) -> *mut std::os::raw::c_void,
        libloading::Error,
    >,
    pub lua_getmetatable: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            objindex: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_getfenv: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_settable: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_setfield: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: std::os::raw::c_int,
            k: *const std::os::raw::c_char,
        ),
        libloading::Error,
    >,
    pub lua_rawset: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_rawseti: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int, n: std::os::raw::c_int),
        libloading::Error,
    >,
    pub lua_setmetatable: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            objindex: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_setfenv: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_call: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            nargs: std::os::raw::c_int,
            nresults: std::os::raw::c_int,
        ),
        libloading::Error,
    >,
    pub lua_pcall: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            nargs: std::os::raw::c_int,
            nresults: std::os::raw::c_int,
            errfunc: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_cpcall: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            func: lua_CFunction,
            ud: *mut std::os::raw::c_void,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_load: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            reader: lua_Reader,
            dt: *mut std::os::raw::c_void,
            chunkname: *const std::os::raw::c_char,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_dump: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            writer: lua_Writer,
            data: *mut std::os::raw::c_void,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_yield: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            nresults: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_resume: Result<
        unsafe extern "C" fn(L: *mut lua_State, narg: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_status:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> std::os::raw::c_int, libloading::Error>,
    pub lua_gc: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            what: std::os::raw::c_int,
            data: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_error:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> std::os::raw::c_int, libloading::Error>,
    pub lua_next: Result<
        unsafe extern "C" fn(L: *mut lua_State, idx: std::os::raw::c_int) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_concat:
        Result<unsafe extern "C" fn(L: *mut lua_State, n: std::os::raw::c_int), libloading::Error>,
    pub lua_getallocf: Result<
        unsafe extern "C" fn(L: *mut lua_State, ud: *mut *mut std::os::raw::c_void) -> lua_Alloc,
        libloading::Error,
    >,
    pub lua_setallocf: Result<
        unsafe extern "C" fn(L: *mut lua_State, f: lua_Alloc, ud: *mut std::os::raw::c_void),
        libloading::Error,
    >,
    pub lua_setlevel:
        Result<unsafe extern "C" fn(from: *mut lua_State, to: *mut lua_State), libloading::Error>,
    pub lua_getstack: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            level: std::os::raw::c_int,
            ar: *mut lua_Debug,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_getinfo: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            what: *const std::os::raw::c_char,
            ar: *mut lua_Debug,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_getlocal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            ar: *const lua_Debug,
            n: std::os::raw::c_int,
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_setlocal: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            ar: *const lua_Debug,
            n: std::os::raw::c_int,
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_getupvalue: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            funcindex: std::os::raw::c_int,
            n: std::os::raw::c_int,
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_setupvalue: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            funcindex: std::os::raw::c_int,
            n: std::os::raw::c_int,
        ) -> *const std::os::raw::c_char,
        libloading::Error,
    >,
    pub lua_sethook: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            func: lua_Hook,
            mask: std::os::raw::c_int,
            count: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
    pub lua_gethook: Result<unsafe extern "C" fn(L: *mut lua_State) -> lua_Hook, libloading::Error>,
    pub lua_gethookmask:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> std::os::raw::c_int, libloading::Error>,
    pub lua_gethookcount:
        Result<unsafe extern "C" fn(L: *mut lua_State) -> std::os::raw::c_int, libloading::Error>,
    pub lua_upvalueid: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx: std::os::raw::c_int,
            n: std::os::raw::c_int,
        ) -> *mut std::os::raw::c_void,
        libloading::Error,
    >,
    pub lua_upvaluejoin: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            idx1: std::os::raw::c_int,
            n1: std::os::raw::c_int,
            idx2: std::os::raw::c_int,
            n2: std::os::raw::c_int,
        ),
        libloading::Error,
    >,
    pub lua_loadx: Result<
        unsafe extern "C" fn(
            L: *mut lua_State,
            reader: lua_Reader,
            dt: *mut std::os::raw::c_void,
            chunkname: *const std::os::raw::c_char,
            mode: *const std::os::raw::c_char,
        ) -> std::os::raw::c_int,
        libloading::Error,
    >,
}

#[allow(clippy::missing_safety_doc)]
impl Lua51 {
    pub unsafe fn new<P>(path: P) -> Result<Self, libloading::Error>
    where
        P: AsRef<std::ffi::OsStr>,
    {
        unsafe {
            let library = libloading::Library::new(path)?;
            Self::from_library(library)
        }
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, libloading::Error>
    where
        L: Into<libloading::Library>,
    {
        unsafe {
            let __library = library.into();
            let lua_newstate = __library.get(b"lua_newstate\0").map(|sym| *sym);
            let lua_close = __library.get(b"lua_close\0").map(|sym| *sym);
            let lua_newthread = __library.get(b"lua_newthread\0").map(|sym| *sym);
            let lua_atpanic = __library.get(b"lua_atpanic\0").map(|sym| *sym);
            let lua_gettop = __library.get(b"lua_gettop\0").map(|sym| *sym);
            let lua_settop = __library.get(b"lua_settop\0").map(|sym| *sym);
            let lua_pushvalue = __library.get(b"lua_pushvalue\0").map(|sym| *sym);
            let lua_remove = __library.get(b"lua_remove\0").map(|sym| *sym);
            let lua_insert = __library.get(b"lua_insert\0").map(|sym| *sym);
            let lua_replace = __library.get(b"lua_replace\0").map(|sym| *sym);
            let lua_checkstack = __library.get(b"lua_checkstack\0").map(|sym| *sym);
            let lua_xmove = __library.get(b"lua_xmove\0").map(|sym| *sym);
            let lua_isnumber = __library.get(b"lua_isnumber\0").map(|sym| *sym);
            let lua_isstring = __library.get(b"lua_isstring\0").map(|sym| *sym);
            let lua_iscfunction = __library.get(b"lua_iscfunction\0").map(|sym| *sym);
            let lua_isuserdata = __library.get(b"lua_isuserdata\0").map(|sym| *sym);
            let lua_type = __library.get(b"lua_type\0").map(|sym| *sym);
            let lua_typename = __library.get(b"lua_typename\0").map(|sym| *sym);
            let lua_equal = __library.get(b"lua_equal\0").map(|sym| *sym);
            let lua_rawequal = __library.get(b"lua_rawequal\0").map(|sym| *sym);
            let lua_lessthan = __library.get(b"lua_lessthan\0").map(|sym| *sym);
            let lua_tonumber = __library.get(b"lua_tonumber\0").map(|sym| *sym);
            let lua_tointeger = __library.get(b"lua_tointeger\0").map(|sym| *sym);
            let lua_toboolean = __library.get(b"lua_toboolean\0").map(|sym| *sym);
            let lua_tolstring = __library.get(b"lua_tolstring\0").map(|sym| *sym);
            let lua_objlen = __library.get(b"lua_objlen\0").map(|sym| *sym);
            let lua_tocfunction = __library.get(b"lua_tocfunction\0").map(|sym| *sym);
            let lua_touserdata = __library.get(b"lua_touserdata\0").map(|sym| *sym);
            let lua_tothread = __library.get(b"lua_tothread\0").map(|sym| *sym);
            let lua_topointer = __library.get(b"lua_topointer\0").map(|sym| *sym);
            let lua_pushnil = __library.get(b"lua_pushnil\0").map(|sym| *sym);
            let lua_pushnumber = __library.get(b"lua_pushnumber\0").map(|sym| *sym);
            let lua_pushinteger = __library.get(b"lua_pushinteger\0").map(|sym| *sym);
            let lua_pushlstring = __library.get(b"lua_pushlstring\0").map(|sym| *sym);
            let lua_pushstring = __library.get(b"lua_pushstring\0").map(|sym| *sym);
            let lua_pushvfstring = __library.get(b"lua_pushvfstring\0").map(|sym| *sym);
            let lua_pushfstring = __library.get(b"lua_pushfstring\0").map(|sym| *sym);
            let lua_pushcclosure = __library.get(b"lua_pushcclosure\0").map(|sym| *sym);
            let lua_pushboolean = __library.get(b"lua_pushboolean\0").map(|sym| *sym);
            let lua_pushlightuserdata = __library.get(b"lua_pushlightuserdata\0").map(|sym| *sym);
            let lua_pushthread = __library.get(b"lua_pushthread\0").map(|sym| *sym);
            let lua_gettable = __library.get(b"lua_gettable\0").map(|sym| *sym);
            let lua_getfield = __library.get(b"lua_getfield\0").map(|sym| *sym);
            let lua_rawget = __library.get(b"lua_rawget\0").map(|sym| *sym);
            let lua_rawgeti = __library.get(b"lua_rawgeti\0").map(|sym| *sym);
            let lua_createtable = __library.get(b"lua_createtable\0").map(|sym| *sym);
            let lua_newuserdata = __library.get(b"lua_newuserdata\0").map(|sym| *sym);
            let lua_getmetatable = __library.get(b"lua_getmetatable\0").map(|sym| *sym);
            let lua_getfenv = __library.get(b"lua_getfenv\0").map(|sym| *sym);
            let lua_settable = __library.get(b"lua_settable\0").map(|sym| *sym);
            let lua_setfield = __library.get(b"lua_setfield\0").map(|sym| *sym);
            let lua_rawset = __library.get(b"lua_rawset\0").map(|sym| *sym);
            let lua_rawseti = __library.get(b"lua_rawseti\0").map(|sym| *sym);
            let lua_setmetatable = __library.get(b"lua_setmetatable\0").map(|sym| *sym);
            let lua_setfenv = __library.get(b"lua_setfenv\0").map(|sym| *sym);
            let lua_call = __library.get(b"lua_call\0").map(|sym| *sym);
            let lua_pcall = __library.get(b"lua_pcall\0").map(|sym| *sym);
            let lua_cpcall = __library.get(b"lua_cpcall\0").map(|sym| *sym);
            let lua_load = __library.get(b"lua_load\0").map(|sym| *sym);
            let lua_dump = __library.get(b"lua_dump\0").map(|sym| *sym);
            let lua_yield = __library.get(b"lua_yield\0").map(|sym| *sym);
            let lua_resume = __library.get(b"lua_resume\0").map(|sym| *sym);
            let lua_status = __library.get(b"lua_status\0").map(|sym| *sym);
            let lua_gc = __library.get(b"lua_gc\0").map(|sym| *sym);
            let lua_error = __library.get(b"lua_error\0").map(|sym| *sym);
            let lua_next = __library.get(b"lua_next\0").map(|sym| *sym);
            let lua_concat = __library.get(b"lua_concat\0").map(|sym| *sym);
            let lua_getallocf = __library.get(b"lua_getallocf\0").map(|sym| *sym);
            let lua_setallocf = __library.get(b"lua_setallocf\0").map(|sym| *sym);
            let lua_setlevel = __library.get(b"lua_setlevel\0").map(|sym| *sym);
            let lua_getstack = __library.get(b"lua_getstack\0").map(|sym| *sym);
            let lua_getinfo = __library.get(b"lua_getinfo\0").map(|sym| *sym);
            let lua_getlocal = __library.get(b"lua_getlocal\0").map(|sym| *sym);
            let lua_setlocal = __library.get(b"lua_setlocal\0").map(|sym| *sym);
            let lua_getupvalue = __library.get(b"lua_getupvalue\0").map(|sym| *sym);
            let lua_setupvalue = __library.get(b"lua_setupvalue\0").map(|sym| *sym);
            let lua_sethook = __library.get(b"lua_sethook\0").map(|sym| *sym);
            let lua_gethook = __library.get(b"lua_gethook\0").map(|sym| *sym);
            let lua_gethookmask = __library.get(b"lua_gethookmask\0").map(|sym| *sym);
            let lua_gethookcount = __library.get(b"lua_gethookcount\0").map(|sym| *sym);
            let lua_upvalueid = __library.get(b"lua_upvalueid\0").map(|sym| *sym);
            let lua_upvaluejoin = __library.get(b"lua_upvaluejoin\0").map(|sym| *sym);
            let lua_loadx = __library.get(b"lua_loadx\0").map(|sym| *sym);
            Ok(Lua51 {
                __library,
                lua_newstate,
                lua_close,
                lua_newthread,
                lua_atpanic,
                lua_gettop,
                lua_settop,
                lua_pushvalue,
                lua_remove,
                lua_insert,
                lua_replace,
                lua_checkstack,
                lua_xmove,
                lua_isnumber,
                lua_isstring,
                lua_iscfunction,
                lua_isuserdata,
                lua_type,
                lua_typename,
                lua_equal,
                lua_rawequal,
                lua_lessthan,
                lua_tonumber,
                lua_tointeger,
                lua_toboolean,
                lua_tolstring,
                lua_objlen,
                lua_tocfunction,
                lua_touserdata,
                lua_tothread,
                lua_topointer,
                lua_pushnil,
                lua_pushnumber,
                lua_pushinteger,
                lua_pushlstring,
                lua_pushstring,
                lua_pushvfstring,
                lua_pushfstring,
                lua_pushcclosure,
                lua_pushboolean,
                lua_pushlightuserdata,
                lua_pushthread,
                lua_gettable,
                lua_getfield,
                lua_rawget,
                lua_rawgeti,
                lua_createtable,
                lua_newuserdata,
                lua_getmetatable,
                lua_getfenv,
                lua_settable,
                lua_setfield,
                lua_rawset,
                lua_rawseti,
                lua_setmetatable,
                lua_setfenv,
                lua_call,
                lua_pcall,
                lua_cpcall,
                lua_load,
                lua_dump,
                lua_yield,
                lua_resume,
                lua_status,
                lua_gc,
                lua_error,
                lua_next,
                lua_concat,
                lua_getallocf,
                lua_setallocf,
                lua_setlevel,
                lua_getstack,
                lua_getinfo,
                lua_getlocal,
                lua_setlocal,
                lua_getupvalue,
                lua_setupvalue,
                lua_sethook,
                lua_gethook,
                lua_gethookmask,
                lua_gethookcount,
                lua_upvalueid,
                lua_upvaluejoin,
                lua_loadx,
            })
        }
    }
    pub unsafe fn lua_newstate(
        &self,
        f: lua_Alloc,
        ud: *mut std::os::raw::c_void,
    ) -> *mut lua_State {
        unsafe {
            self.lua_newstate
                .as_ref()
                .expect("Expected function, got error.")(f, ud)
        }
    }
    pub unsafe fn lua_close(&self, L: *mut lua_State) {
        unsafe {
            self.lua_close
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_newthread(&self, L: *mut lua_State) -> *mut lua_State {
        unsafe {
            self.lua_newthread
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_atpanic(&self, L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction {
        unsafe {
            self.lua_atpanic
                .as_ref()
                .expect("Expected function, got error.")(L, panicf)
        }
    }
    pub unsafe fn lua_gettop(&self, L: *mut lua_State) -> std::os::raw::c_int {
        unsafe {
            self.lua_gettop
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_settop(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_settop
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_pushvalue(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_pushvalue
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_remove(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_remove
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_insert(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_insert
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_replace(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_replace
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_checkstack(
        &self,
        L: *mut lua_State,
        sz: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_checkstack
                .as_ref()
                .expect("Expected function, got error.")(L, sz)
        }
    }
    pub unsafe fn lua_xmove(
        &self,
        from: *mut lua_State,
        to: *mut lua_State,
        n: std::os::raw::c_int,
    ) {
        unsafe {
            self.lua_xmove
                .as_ref()
                .expect("Expected function, got error.")(from, to, n)
        }
    }
    pub unsafe fn lua_isnumber(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_isnumber
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_isstring(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_isstring
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_iscfunction(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_iscfunction
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_isuserdata(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_isuserdata
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_type(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_type
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_typename(
        &self,
        L: *mut lua_State,
        tp: std::os::raw::c_int,
    ) -> *const std::os::raw::c_char {
        unsafe {
            self.lua_typename
                .as_ref()
                .expect("Expected function, got error.")(L, tp)
        }
    }
    pub unsafe fn lua_equal(
        &self,
        L: *mut lua_State,
        idx1: std::os::raw::c_int,
        idx2: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_equal
                .as_ref()
                .expect("Expected function, got error.")(L, idx1, idx2)
        }
    }
    pub unsafe fn lua_rawequal(
        &self,
        L: *mut lua_State,
        idx1: std::os::raw::c_int,
        idx2: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_rawequal
                .as_ref()
                .expect("Expected function, got error.")(L, idx1, idx2)
        }
    }
    pub unsafe fn lua_lessthan(
        &self,
        L: *mut lua_State,
        idx1: std::os::raw::c_int,
        idx2: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_lessthan
                .as_ref()
                .expect("Expected function, got error.")(L, idx1, idx2)
        }
    }
    pub unsafe fn lua_tonumber(&self, L: *mut lua_State, idx: std::os::raw::c_int) -> lua_Number {
        unsafe {
            self.lua_tonumber
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_tointeger(&self, L: *mut lua_State, idx: std::os::raw::c_int) -> lua_Integer {
        unsafe {
            self.lua_tointeger
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_toboolean(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_toboolean
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_tolstring(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
        len: *mut usize,
    ) -> *const std::os::raw::c_char {
        unsafe {
            self.lua_tolstring
                .as_ref()
                .expect("Expected function, got error.")(L, idx, len)
        }
    }
    pub unsafe fn lua_objlen(&self, L: *mut lua_State, idx: std::os::raw::c_int) -> usize {
        unsafe {
            self.lua_objlen
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_tocfunction(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> lua_CFunction {
        unsafe {
            self.lua_tocfunction
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_touserdata(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_void {
        unsafe {
            self.lua_touserdata
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_tothread(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> *mut lua_State {
        unsafe {
            self.lua_tothread
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_topointer(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> *const std::os::raw::c_void {
        unsafe {
            self.lua_topointer
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_pushnil(&self, L: *mut lua_State) {
        unsafe {
            self.lua_pushnil
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_pushnumber(&self, L: *mut lua_State, n: lua_Number) {
        unsafe {
            self.lua_pushnumber
                .as_ref()
                .expect("Expected function, got error.")(L, n)
        }
    }
    pub unsafe fn lua_pushinteger(&self, L: *mut lua_State, n: lua_Integer) {
        unsafe {
            self.lua_pushinteger
                .as_ref()
                .expect("Expected function, got error.")(L, n)
        }
    }
    pub unsafe fn lua_pushlstring(
        &self,
        L: *mut lua_State,
        s: *const std::os::raw::c_char,
        l: usize,
    ) {
        unsafe {
            self.lua_pushlstring
                .as_ref()
                .expect("Expected function, got error.")(L, s, l)
        }
    }
    pub unsafe fn lua_pushstring(&self, L: *mut lua_State, s: *const std::os::raw::c_char) {
        unsafe {
            self.lua_pushstring
                .as_ref()
                .expect("Expected function, got error.")(L, s)
        }
    }
    pub unsafe fn lua_pushvfstring(
        &self,
        L: *mut lua_State,
        fmt: *const std::os::raw::c_char,
        argp: *mut __va_list_tag,
    ) -> *const std::os::raw::c_char {
        unsafe {
            self.lua_pushvfstring
                .as_ref()
                .expect("Expected function, got error.")(L, fmt, argp)
        }
    }
    pub unsafe fn lua_pushcclosure(
        &self,
        L: *mut lua_State,
        fn_: lua_CFunction,
        n: std::os::raw::c_int,
    ) {
        unsafe {
            self.lua_pushcclosure
                .as_ref()
                .expect("Expected function, got error.")(L, fn_, n)
        }
    }
    pub unsafe fn lua_pushboolean(&self, L: *mut lua_State, b: std::os::raw::c_int) {
        unsafe {
            self.lua_pushboolean
                .as_ref()
                .expect("Expected function, got error.")(L, b)
        }
    }
    pub unsafe fn lua_pushlightuserdata(&self, L: *mut lua_State, p: *mut std::os::raw::c_void) {
        unsafe {
            self.lua_pushlightuserdata
                .as_ref()
                .expect("Expected function, got error.")(L, p)
        }
    }
    pub unsafe fn lua_pushthread(&self, L: *mut lua_State) -> std::os::raw::c_int {
        unsafe {
            self.lua_pushthread
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_gettable(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_gettable
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_getfield(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
        k: *const std::os::raw::c_char,
    ) {
        unsafe {
            self.lua_getfield
                .as_ref()
                .expect("Expected function, got error.")(L, idx, k)
        }
    }
    pub unsafe fn lua_rawget(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_rawget
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_rawgeti(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
        n: std::os::raw::c_int,
    ) {
        unsafe {
            self.lua_rawgeti
                .as_ref()
                .expect("Expected function, got error.")(L, idx, n)
        }
    }
    pub unsafe fn lua_createtable(
        &self,
        L: *mut lua_State,
        narr: std::os::raw::c_int,
        nrec: std::os::raw::c_int,
    ) {
        unsafe {
            self.lua_createtable
                .as_ref()
                .expect("Expected function, got error.")(L, narr, nrec)
        }
    }
    pub unsafe fn lua_newuserdata(
        &self,
        L: *mut lua_State,
        sz: usize,
    ) -> *mut std::os::raw::c_void {
        unsafe {
            self.lua_newuserdata
                .as_ref()
                .expect("Expected function, got error.")(L, sz)
        }
    }
    pub unsafe fn lua_getmetatable(
        &self,
        L: *mut lua_State,
        objindex: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_getmetatable
                .as_ref()
                .expect("Expected function, got error.")(L, objindex)
        }
    }
    pub unsafe fn lua_getfenv(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_getfenv
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_settable(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_settable
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_setfield(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
        k: *const std::os::raw::c_char,
    ) {
        unsafe {
            self.lua_setfield
                .as_ref()
                .expect("Expected function, got error.")(L, idx, k)
        }
    }
    pub unsafe fn lua_rawset(&self, L: *mut lua_State, idx: std::os::raw::c_int) {
        unsafe {
            self.lua_rawset
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_rawseti(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
        n: std::os::raw::c_int,
    ) {
        unsafe {
            self.lua_rawseti
                .as_ref()
                .expect("Expected function, got error.")(L, idx, n)
        }
    }
    pub unsafe fn lua_setmetatable(
        &self,
        L: *mut lua_State,
        objindex: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_setmetatable
                .as_ref()
                .expect("Expected function, got error.")(L, objindex)
        }
    }
    pub unsafe fn lua_setfenv(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_setfenv
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_call(
        &self,
        L: *mut lua_State,
        nargs: std::os::raw::c_int,
        nresults: std::os::raw::c_int,
    ) {
        unsafe {
            self.lua_call
                .as_ref()
                .expect("Expected function, got error.")(L, nargs, nresults)
        }
    }
    pub unsafe fn lua_pcall(
        &self,
        L: *mut lua_State,
        nargs: std::os::raw::c_int,
        nresults: std::os::raw::c_int,
        errfunc: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_pcall
                .as_ref()
                .expect("Expected function, got error.")(L, nargs, nresults, errfunc)
        }
    }
    pub unsafe fn lua_cpcall(
        &self,
        L: *mut lua_State,
        func: lua_CFunction,
        ud: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_cpcall
                .as_ref()
                .expect("Expected function, got error.")(L, func, ud)
        }
    }
    pub unsafe fn lua_load(
        &self,
        L: *mut lua_State,
        reader: lua_Reader,
        dt: *mut std::os::raw::c_void,
        chunkname: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_load
                .as_ref()
                .expect("Expected function, got error.")(L, reader, dt, chunkname)
        }
    }
    pub unsafe fn lua_dump(
        &self,
        L: *mut lua_State,
        writer: lua_Writer,
        data: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_dump
                .as_ref()
                .expect("Expected function, got error.")(L, writer, data)
        }
    }
    pub unsafe fn lua_yield(
        &self,
        L: *mut lua_State,
        nresults: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_yield
                .as_ref()
                .expect("Expected function, got error.")(L, nresults)
        }
    }
    pub unsafe fn lua_resume(
        &self,
        L: *mut lua_State,
        narg: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_resume
                .as_ref()
                .expect("Expected function, got error.")(L, narg)
        }
    }
    pub unsafe fn lua_status(&self, L: *mut lua_State) -> std::os::raw::c_int {
        unsafe {
            self.lua_status
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_gc(
        &self,
        L: *mut lua_State,
        what: std::os::raw::c_int,
        data: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe { self.lua_gc.as_ref().expect("Expected function, got error.")(L, what, data) }
    }
    pub unsafe fn lua_error(&self, L: *mut lua_State) -> std::os::raw::c_int {
        unsafe {
            self.lua_error
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_next(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_next
                .as_ref()
                .expect("Expected function, got error.")(L, idx)
        }
    }
    pub unsafe fn lua_concat(&self, L: *mut lua_State, n: std::os::raw::c_int) {
        unsafe {
            self.lua_concat
                .as_ref()
                .expect("Expected function, got error.")(L, n)
        }
    }
    pub unsafe fn lua_getallocf(
        &self,
        L: *mut lua_State,
        ud: *mut *mut std::os::raw::c_void,
    ) -> lua_Alloc {
        unsafe {
            self.lua_getallocf
                .as_ref()
                .expect("Expected function, got error.")(L, ud)
        }
    }
    pub unsafe fn lua_setallocf(
        &self,
        L: *mut lua_State,
        f: lua_Alloc,
        ud: *mut std::os::raw::c_void,
    ) {
        unsafe {
            self.lua_setallocf
                .as_ref()
                .expect("Expected function, got error.")(L, f, ud)
        }
    }
    pub unsafe fn lua_setlevel(&self, from: *mut lua_State, to: *mut lua_State) {
        unsafe {
            self.lua_setlevel
                .as_ref()
                .expect("Expected function, got error.")(from, to)
        }
    }
    pub unsafe fn lua_getstack(
        &self,
        L: *mut lua_State,
        level: std::os::raw::c_int,
        ar: *mut lua_Debug,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_getstack
                .as_ref()
                .expect("Expected function, got error.")(L, level, ar)
        }
    }
    pub unsafe fn lua_getinfo(
        &self,
        L: *mut lua_State,
        what: *const std::os::raw::c_char,
        ar: *mut lua_Debug,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_getinfo
                .as_ref()
                .expect("Expected function, got error.")(L, what, ar)
        }
    }
    pub unsafe fn lua_getlocal(
        &self,
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: std::os::raw::c_int,
    ) -> *const std::os::raw::c_char {
        unsafe {
            self.lua_getlocal
                .as_ref()
                .expect("Expected function, got error.")(L, ar, n)
        }
    }
    pub unsafe fn lua_setlocal(
        &self,
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: std::os::raw::c_int,
    ) -> *const std::os::raw::c_char {
        unsafe {
            self.lua_setlocal
                .as_ref()
                .expect("Expected function, got error.")(L, ar, n)
        }
    }
    pub unsafe fn lua_getupvalue(
        &self,
        L: *mut lua_State,
        funcindex: std::os::raw::c_int,
        n: std::os::raw::c_int,
    ) -> *const std::os::raw::c_char {
        unsafe {
            self.lua_getupvalue
                .as_ref()
                .expect("Expected function, got error.")(L, funcindex, n)
        }
    }
    pub unsafe fn lua_setupvalue(
        &self,
        L: *mut lua_State,
        funcindex: std::os::raw::c_int,
        n: std::os::raw::c_int,
    ) -> *const std::os::raw::c_char {
        unsafe {
            self.lua_setupvalue
                .as_ref()
                .expect("Expected function, got error.")(L, funcindex, n)
        }
    }
    pub unsafe fn lua_sethook(
        &self,
        L: *mut lua_State,
        func: lua_Hook,
        mask: std::os::raw::c_int,
        count: std::os::raw::c_int,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_sethook
                .as_ref()
                .expect("Expected function, got error.")(L, func, mask, count)
        }
    }
    pub unsafe fn lua_gethook(&self, L: *mut lua_State) -> lua_Hook {
        unsafe {
            self.lua_gethook
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_gethookmask(&self, L: *mut lua_State) -> std::os::raw::c_int {
        unsafe {
            self.lua_gethookmask
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_gethookcount(&self, L: *mut lua_State) -> std::os::raw::c_int {
        unsafe {
            self.lua_gethookcount
                .as_ref()
                .expect("Expected function, got error.")(L)
        }
    }
    pub unsafe fn lua_upvalueid(
        &self,
        L: *mut lua_State,
        idx: std::os::raw::c_int,
        n: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_void {
        unsafe {
            self.lua_upvalueid
                .as_ref()
                .expect("Expected function, got error.")(L, idx, n)
        }
    }
    pub unsafe fn lua_upvaluejoin(
        &self,
        L: *mut lua_State,
        idx1: std::os::raw::c_int,
        n1: std::os::raw::c_int,
        idx2: std::os::raw::c_int,
        n2: std::os::raw::c_int,
    ) {
        unsafe {
            self.lua_upvaluejoin
                .as_ref()
                .expect("Expected function, got error.")(L, idx1, n1, idx2, n2)
        }
    }
    pub unsafe fn lua_loadx(
        &self,
        L: *mut lua_State,
        reader: lua_Reader,
        dt: *mut std::os::raw::c_void,
        chunkname: *const std::os::raw::c_char,
        mode: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int {
        unsafe {
            self.lua_loadx
                .as_ref()
                .expect("Expected function, got error.")(L, reader, dt, chunkname, mode)
        }
    }
}
